-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local CylinderRenderer = TS.import(script, script.Parent, "Renderers", "CylinderRenderer").CylinderRenderer
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
--[[
	*
	* A projectile that simulates physical interactions with the world according to the given configuration
]]
local Projectile
do
	Projectile = setmetatable({}, {
		__tostring = function()
			return "Projectile"
		end,
	})
	Projectile.__index = Projectile
	function Projectile.new(...)
		local self = setmetatable({}, Projectile)
		self:constructor(...)
		return self
	end
	function Projectile:constructor(config)
		self.distanceSq = 0
		-- default values
		local _0 = config
		local bounce = _0.bounce
		if bounce == nil then
			bounce = false
		end
		local canCollide = _0.canCollide
		if canCollide == nil then
			canCollide = true
		end
		local life = _0.life
		if life == nil then
			life = 2
		end
		local maxRange = _0.maxRange
		if maxRange == nil then
			maxRange = 5000
		end
		local minExitVelocity = _0.minExitVelocity
		if minExitVelocity == nil then
			minExitVelocity = 100
		end
		local penetration = _0.penetration
		if penetration == nil then
			penetration = false
		end
		local physicsIgnore = _0.physicsIgnore
		if physicsIgnore == nil then
			physicsIgnore = {}
		end
		local renderer = _0.renderer
		if renderer == nil then
			renderer = CylinderRenderer.new(Color3.new(1, 1, 1))
		end
		local resistance = _0.resistance
		if resistance == nil then
			resistance = 1
		end
		self.px = config.position.X
		self.py = config.position.Y
		self.pz = config.position.Z
		self.vx = config.velocity.X
		self.vy = config.velocity.Y
		self.vz = config.velocity.Z
		self.ax = config.acceleration.X
		self.ay = config.acceleration.Y
		self.az = config.acceleration.Z
		self.bounce = bounce
		self.canCollide = canCollide
		self.lifeTime = Projectile.elapsedTime + life
		self.maxRangeSq = maxRange ^ 2
		self.minExitVelocity = minExitVelocity
		local _1 = {}
		local _2 = #_1
		for _3, _4 in ipairs(Projectile.globalPhysicsIgnore) do
			_1[_2 + _3] = _4
		end
		_2 = #_1
		for _3, _4 in ipairs(renderer.physicsIgnore) do
			_1[_2 + _3] = _4
		end
		_2 = #_1
		for _3, _4 in ipairs(physicsIgnore) do
			_1[_2 + _3] = _4
		end
		self.physicsIgnore = _1
		self.penetration = penetration
		self.resistance = resistance
		self.onTouch = config.onTouch
		self.renderer = renderer
		local _3 = Projectile.projectiles
		local _4 = self
		-- ▼ Array.push ▼
		_3[#_3 + 1] = _4
		-- ▲ Array.push ▲
	end
	function Projectile:addToPhysicsIgnore(object)
		for _, v in ipairs(Projectile.globalPhysicsIgnore) do
			if v == object then
				return nil
			end
		end
		local _0 = Projectile.globalPhysicsIgnore
		local _1 = object
		-- ▼ Array.push ▼
		_0[#_0 + 1] = _1
		-- ▲ Array.push ▲
		object:GetPropertyChangedSignal("Parent"):Connect(function()
			if not object.Parent then
				local _2 = Projectile.globalPhysicsIgnore
				local _3 = object
				local index = (table.find(_2, _3) or 0) - 1
				if index ~= -1 then
					local _4 = Projectile.globalPhysicsIgnore
					local _5 = index
					table.remove(_4, _5 + 1)
				end
			end
		end)
	end
	function Projectile:raycast(start, direction, ignore)
		return Workspace:FindPartOnRayWithIgnoreList(Ray.new(start, direction), ignore, false, true)
	end
	function Projectile:step(dt)
		-- store original position
		local pxOrig = self.px
		local pyOrig = self.py
		local pzOrig = self.pz
		-- store original velocity
		local vxOrig = self.vx
		local vyOrig = self.vy
		local vzOrig = self.vz
		-- update velocity
		self.vx += dt * self.ax
		self.vy += dt * self.ay
		self.vz += dt * self.az
		-- expected delta
		local dx = (dt * (vxOrig + self.vx)) / 2
		local dy = (dt * (vyOrig + self.vy)) / 2
		local dz = (dt * (vzOrig + self.vz)) / 2
		if self.canCollide and (dx ~= 0 or dy ~= 0 or dz ~= 0) then
			local dir = Vector3.new(dx, dy, dz)
			local startPos = Vector3.new(self.px, self.py, self.pz)
			local part, pos, norm = Projectile:raycast(startPos, dir, self.physicsIgnore)
			if part then
				local didPenetrate = false
				if self.penetration then
					local unitDir = dir.Unit
					local _0 = unitDir
					local _1 = part.Size.Magnitude
					local exitDir = _0 * _1
					local _, nextPos = Projectile:raycast(pos, exitDir, self.physicsIgnore)
					local _, exit = Projectile:raycast(nextPos, exitDir * (-1), self.physicsIgnore)
					local _2 = unitDir
					local _3 = exit
					local _4 = pos
					local distance = _2:Dot(_3 - _4)
					if distance > 0 then
						local currentVelocity = Vector3.new(vxOrig, vyOrig, vzOrig).Magnitude
						if distance < math.log(currentVelocity / self.minExitVelocity) / self.resistance then
							self.px = exit.X
							self.py = exit.Y
							self.pz = exit.Z
							local gv = math.exp(-self.resistance * distance)
							self.vx *= gv
							self.vy *= gv
							self.vz *= gv
							didPenetrate = true
						end
					end
				end
				if not didPenetrate then
					self.px = pos.X
					self.py = pos.Y
					self.pz = pos.Z
					if self.bounce then
						local vDot = -2 * (self.vx * norm.X + self.vy * norm.Y + self.vz * norm.Z)
						local RS = 0.9
						self.vx = RS * (vDot * norm.X + self.vx)
						self.vy = RS * (vDot * norm.Y + self.vy)
						self.vz = RS * (vDot * norm.Z + self.vz)
					else
						self:remove()
					end
				end
				local _0 = self.onTouch
				if _0 ~= 0 and _0 == _0 and _0 ~= "" and _0 then
					_0 = self.onTouch(part, pos, norm, Vector3.new(self.vx, self.vy, self.vz).Unit) == true
				end
				if _0 then
					self:remove(true)
					return nil
				end
			else
				self.px = pos.X
				self.py = pos.Y
				self.pz = pos.Z
			end
			-- actual delta
			dx = self.px - pxOrig
			dy = self.py - pyOrig
			dz = self.pz - pzOrig
		else
			-- no collision, move without raycasting
			self.px += dx
			self.py += dy
			self.pz += dz
		end
		-- remove if distance is too far
		self.distanceSq += dx ^ 2 + dy ^ 2 + dz ^ 2
		if self.distanceSq > self.maxRangeSq then
			self:remove()
			return nil
		end
		-- render
		local origPos = Vector3.new(pxOrig, pyOrig, pzOrig)
		local direction = Vector3.new(dx, dy, dz)
		self.renderer:render(origPos, direction.Unit)
	end
	function Projectile:remove(instantly)
		if instantly == nil then
			instantly = false
		end
		if instantly then
			self.renderer:destroy()
		end
		local _0 = Projectile.removeList
		local _1 = self
		-- ▼ Set.add ▼
		_0[_1] = true
		-- ▲ Set.add ▲
	end
	Projectile.elapsedTime = 0
	Projectile.projectiles = {}
	Projectile.removeList = {}
	Projectile.globalPhysicsIgnore = {}
end
local raycastIgnore = Workspace:FindFirstChild("Ignore")
if raycastIgnore then
	local _0 = Projectile.globalPhysicsIgnore
	local _1 = raycastIgnore
	-- ▼ Array.push ▼
	_0[#_0 + 1] = _1
	-- ▲ Array.push ▲
end
RunService.RenderStepped:Connect(function(dt)
	Projectile.elapsedTime += dt
	local newProjectiles = {}
	for _, p in ipairs(Projectile.projectiles) do
		local _0 = Projectile.removeList
		local _1 = p
		local _2 = _0[_1] ~= nil
		if not _2 then
			_2 = p.lifeTime < Projectile.elapsedTime
		end
		if _2 then
			p.renderer:destroy()
			local _3 = Projectile.removeList
			local _4 = p
			-- ▼ Set.delete ▼
			_3[_4] = nil
			-- ▲ Set.delete ▲
		else
			local _3 = newProjectiles
			local _4 = p
			-- ▼ Array.push ▼
			_3[#_3 + 1] = _4
			-- ▲ Array.push ▲
			p:step(dt)
		end
	end
	Projectile.projectiles = newProjectiles
end)
return {
	Projectile = Projectile,
}
